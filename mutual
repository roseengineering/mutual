#!/usr/bin/python3

import subprocess, tempfile, os
import numpy as np

defaults = {
    "diameter": 25 / 1000,
    "losses": 0,
    "loading": 0,
    "segments": 21,
    "vf": 0.66,
    "k": 0.25,
    "l": 25e-6,
    "power": 100,
    "feed": 50,
    "output": 50,
    "frequencies": [ 3.5 ]
}


def run_process(text):
    name = tempfile.mktemp()
    command = 'nec2c -i %s -o /dev/stdout' % name
    with open(name, "wb") as f:
        f.write(text.encode()) 
    proc = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE)
    result = proc.stdout.read().decode()
    proc.wait()
    os.unlink(name)
    return result


def run_nec(text):
    tag = None
    im = []
    buf = run_process(text)
    f = iter(buf.splitlines())
    for line in f:
        data = line.split()
        if len(data) == 10 and data[0].isdigit() and '.' in line: break
    while True:
        data = line.split() 
        if not len(data): break
        x = np.complex(np.double(data[6]), np.double(data[7]))
        if tag != data[1]:
            im.append(x)
            tag = data[1]
        line = next(f)
    return im


def generate_input(data, voltages):
    frequency = data["frequency"]
    element = data['element']
    height = data['height']
    radius = data["diameter"] / 2
    losses = data["losses"]
    loading = data["loading"]
    segments = data["segments"]
    text = ""
    n = len(element)
    for i in range(n):
        tag = i + 1
        fmt = "GW {tag} {segments} {x:g} {y:g} 0 {x:g} {y:g} {height} {radius}\n"
        text += fmt.format(tag=tag, segments=segments, 
                           x=element[i][0], y=element[i][1], 
                           height=height, radius=radius)
    text += "GE 1\n"  # ground plane is present
    text += "GN 1\n"  # perfect ground
    text += "FR 0 0 0 0 {:f}\n".format(frequency)
    for i in range(n):
        tag = i + 1
        text += "LD 4 {:d} 1 1 {:f} {:f}\n".format(tag, losses, loading)
    for i in range(n):
        tag = i + 1
        text += "EX 0 {:d} 1 0 {:g} {:g}\n".format(tag, voltages[i].real, voltages[i].imag)
    text += "XQ\n"
    text += "EN\n"
    return text


def multiply(zij, ii):
    ei = np.matrix(zij) * np.matrix(ii).T
    return np.array(ei).T[0]


def autoload(data):
    d = { "element": [ (0, 0) ] }
    ei = [ 1 ]
    ii = run_nec(generate_input(dict(data, **d), ei))
    zself = 1 / ii[0]
    print('! autoload vertical base   = {:.4f}j'.format(-zself.imag))
    data["loading"] = -zself.imag


def mutual(data):
    n = len(data["element"])
    zij = np.zeros((n, n), dtype=np.complex)
    for k in range(n):
        ei = np.ones(n) * 1e-20
        ei[k] = 1
        ii = run_nec(generate_input(data, ei))
        zij[:,k] = ii
    zij = np.array(np.linalg.inv(np.matrix(zij)))
    return zij


def error_norm(zij, data):
    n = zij.shape[0]
    ii = np.ones(n)
    ei = multiply(zij, ii)
    err = ii - run_nec(generate_input(data, ei))
    print('! error norm       = {:g}'.format(np.linalg.norm(err)))


def to_complex(buf, f=None, vf=None):
    buf = buf.strip()
    if '/' in buf:
        r, theta = buf.split('/')
        if theta[-2:] == 'ft':
            theta = np.double(theta[:-2]) * .3048
            theta = 360 * theta / vf / (300 / f)
        elif theta[-1:] == 'm':
            theta = np.double(theta[:-1])
            theta = 360 * theta / vf / (300 / f)
        return np.double(r) * np.exp(1j * np.deg2rad(np.double(theta)))
    else:
        return np.complex(buf)


def to_distance(buf):
    buf = buf.strip()
    if len(buf) > 2:
        suffix = buf[-2:]
        s = buf[:-2]
        if suffix == 'cm':
            return np.double(s) * .01
        if suffix == 'mm':
            return np.double(s) * .001
        if suffix == 'in':
            return np.double(s) * .0254
        if suffix == 'ft':
            return np.double(s) * .3048
    return np.double(buf)
    

def parallel(zi):
    return 1 / np.sum([ 1 / x for x in zi ])


def tline(deg, zo=50):
    theta = np.deg2rad(deg)
    return np.matrix([
        [ np.cos(theta), 1j * zo * np.sin(theta) ],
        [ 1j * np.sin(theta) / zo, np.cos(theta) ]
    ])


def print_drive(zij, data):
    n = zij.shape[0]
    frequency = data["frequency"]
    ii = np.array(data["current"])
    ei = multiply(zij, ii)

    # tlines from antenna to ATU

    if data.get("tline1"):
        for i, x in enumerate(data["tline1"]):
            x = to_complex(x, f=frequency, vf=data["vf"])
            ei[i], ii[i] = multiply(tline(np.rad2deg(np.angle(x)), zo=np.abs(x)), [ei[i], ii[i]])

    if data.get("divider1") or data.get("divider2") or data.get("divider3") or data.get("k2bt"):
        solve(ei, ii, data)
    else:
        zi = ei / ii
        ztot = parallel(zi)
        print('{:<8g}'.format(frequency), end="")
        print(','.join([ ' {:8.4f} {:+8.4f}j'.format(x.real, x.imag) for x in zi ]))
        print('! E in MA notation =', end="")
        print(','.join([ ' {:8.4f} {:8.4f}'.format(np.abs(x), np.rad2deg(np.angle(x))) for x in ei ]))
        print('! I in MA notation =', end="")
        print(','.join([ ' {:8.4f} {:8.4f}'.format(np.abs(x), np.rad2deg(np.angle(x))) for x in ii ]))
        print('! Z in parallel    =', end="")
        print(' {:8.4f} {:+8.4f}j'.format(ztot.real, ztot.imag))


def print_mutual(zij, data):
    n = zij.shape[0]
    frequency = data["frequency"]
    print('{:<8g}'.format(frequency), end="")
    for i in range(n):
        if i > 0: print('{:<8s}'.format(''), end="")
        print(','.join([ ' {:8.4f} {:+8.4f}j'.format(
              zij[i][j].real, zij[i][j].imag) for j in range(n) ]))

   
def main(*args):
    args = list(args)
    kw = { "element": [] }
    while args:
        opt = args.pop(0)
        if opt == '-debug':
            kw["debug"] = True
        elif opt == '-autoload':
            kw["autoload"] = True
        elif opt == '-k2bt':
            kw["k2bt"] = True
        elif opt == '-z':
            kw["z"] = [ np.complex(x) for x in args.pop(0).split(',') ]
        elif opt == '-divider1':
            kw["divider1"] = True
        elif opt == '-divider2':
            kw["divider2"] = True
        elif opt == '-divider3':
            kw["divider3"] = True
        elif opt == '-freq':
            kw["frequencies"] = [ np.double(x) for x in args.pop(0).split(',') ]
        elif opt == '-loss':
            kw["losses"] = np.double(args.pop(0))
        elif opt == '-load':
            kw["loading"] = np.double(args.pop(0))
        elif opt == '-segs':
            kw["segments"] = np.int(args.pop(0))
        elif opt == '-height':
            kw["height"] = to_distance(args.pop(0))
        elif opt == '-diam':
            kw["diameter"] = to_distance(args.pop(0))
        elif opt == '-el':
            kw["element"].append([ to_distance(x) for x in args.pop(0).split(',') ])
        elif opt == '-current':
            kw["current"] = [ to_complex(x) for x in args.pop(0).split(',') ]
        elif opt == '-tie':
            kw["tie"] = [ np.int(x) for x in args.pop(0).split(',') ]
        elif opt == '-tline1':
            kw["tline1"] = args.pop(0).split(',')
        elif opt == '-tline2':
            kw["tline2"] = args.pop(0).split(',')
        elif opt == '-vf':
            kw["vf"] = np.double(args.pop(0))
        elif opt == '-k':
            kw["k"] = np.double(args.pop(0))
        elif opt == '-l':
            kw["l"] = np.double(args.pop(0))
        elif opt == '-power':
            kw["power"] = np.double(args.pop(0))
        elif opt == '-feed':
            kw["feed"] = np.double(args.pop(0))
        elif opt == '-output':
            kw["output"] = np.double(args.pop(0))
        elif opt == '-direct':
            kw["direct"] = True
        else:
            raise ValueError("unknown option:", opt)

    kw = dict(defaults, **kw)
    print("! MHZ Z RI R 1")
    for frequency in kw["frequencies"]:
        kw["frequency"] = frequency

        if kw.get('z'):
            zij = kw["z"] * np.identity(len(kw["z"]))
        else:
            if kw.get('autoload'):
                autoload(kw)
            zij = mutual(kw)

            # calculate error norm

            if kw.get('debug'):
                error_norm(zij, kw)

        # display results

        if kw.get("current"):
            print_drive(zij, kw)
        else:
            print_mutual(zij, kw)


######################

def bisect(f, a, b):
    for n in range(100):
        c = (a + b) / 2
        if np.abs(f(c) - f(a)) < 1e-5: break
        if np.sign(f(c)) == np.sign(f(a)): a = c
        else: b= c
    return c


def shuntmatch(P, R, V, L, F, K, flag=None):
    #  V o---L1---+----(-M)--+ P
    #            L2          R
    sign = 1 
    W = 2 * np.pi * F
    def func(M):
        return (R * V**2 * (L/2 + sign * np.sqrt((2 * M - L)**2 / 4 - M**2 / K**2))**2 /
               (R**2 * L**2 + W**2 * M**4 * (1 - K**2) / K**4))
    func2 = lambda M: P - func(M)
    coil2 = lambda M: L/2 - np.sqrt((2 * M - L)**2 / 4 - M**2 / K**2)
    shift = lambda M: np.arctan(W * (1 - K**2) * M**2 / (R * L * K**2))
    mmax = lambda: L * K / (2 + 2 * K)
    sign = 1 if func(mmax()) < P else -1
    m = bisect(func2, 0, mmax())
    if np.abs(func2(m)) > .1: m = np.nan
    L2 = coil2(m)
    L1 = L - L2
    return np.array([ -m, L2, L1 ]) * W if flag else shift(m) 


def lmatch(ZS, ZL):
    """
    ZS <---+---X2--< ZL
           X1   
    """
    RS, XS = ZS.real, ZS.imag
    RL, XL = ZL.real, ZL.imag
    QS = RS / RL - 1 + XS**2 / (RS * RL)
    Q = np.sqrt(QS)
    X1 = (XS + np.array([1, -1]) * Q * RS) / (RS / RL - 1)
    X2 = -(XL + np.array([1, -1]) * Q * RL)
    return np.array([X1, X2]).T


def component(x, f, precision=5):
    if np.isinf(x) or np.isnan(x) or x == 0: return '-'
    assert(x.imag == 0)
    f = f * 1e6
    w = 2 * np.pi * f
    x = 1 / (w * x) if x < 0 else x / w
    UNITS = 'FH'
    SUFFIX = ["f", "p", "n", "u", "m", "", "k", "M", "G"]
    exp = np.floor(np.log10(np.abs(x)))
    mant = np.round(x / 10**exp, precision-1)
    p = np.int(exp // 3)
    value = (mant * 10**exp) / 10**(3 * p)
    if p - 4 >= 0 or p - 4 < -len(SUFFIX):
        return "%7.2g%s" % (np.abs(x), UNITS[0 if x < 0 else 1])
    else:
        return "%6.4g%s%s" % (np.abs(value), SUFFIX[p-4], UNITS[0 if x < 0 else 1])


def pishift(theta, r1, r2):
    x1, x2, x3 = teeshift(theta, 1/r1, 1/r2)
    return -1/x1, -1/x2, -1/x3


def teeshift(theta, r1, r2):
    theta = np.deg2rad(theta)
    zo = np.sqrt(np.abs(r1 * r2))
    x1 = np.sign(r1) * (zo - np.abs(r1) * np.cos(theta)) / np.sin(theta)
    x2 = np.sign(r1) * -zo / np.sin(theta)
    x3 = np.sign(r1) * (zo - np.abs(r2) * np.cos(theta)) / np.sin(theta)
    return x1, x2, x3


def watts(v):
    return np.abs(v[1])**2 * (v[0]/v[1]).real


def pinet(v, x1, x2, x3):
    y1 = 1 / x1
    y3 = 1 / x3
    v = multiply([[1, 0], [-1j*y1, 1]], v)  # shunt
    v = multiply([[1, 1j*x2], [0, 1]], v)   # series
    v = multiply([[1, 0], [-1j*y3, 1]], v)  # shunt
    return v


def teenet(v, x1, x2, x3):
    y2 = 1 / x2
    v = multiply([[1, 1j*x1], [0, 1]], v)   # series
    v = multiply([[1, 0], [-1j*y2, 1]], v)  # shunt
    v = multiply([[1, 1j*x3], [0, 1]], v)   # series
    return v


def lmatchnet(v, x, reverse=False):
    if reverse:
        v = multiply([[1, 1j*x[1]], [0, 1]], v)        # series
        v = multiply([[1, 0], [1 / (1j*x[0]), 1]], v)  # shunt
    else:
        v = multiply([[1, 0], [1 / (1j*x[0]), 1]], v)  # shunt
        v = multiply([[1, 1j*x[1]], [0, 1]], v)        # series
    return v
                    

def solve(ei, ii, data):
    n = len(ei)
    frequency = data["frequency"]
    zi = ei / ii
    feede_common = np.sqrt(data["power"] * data["output"])

    # transmitter power 

    ratio = np.sqrt(data["power"] / np.sum(np.abs(ii**2) * zi.real))
    ei *= ratio
    ii *= ratio
    power = np.abs(ii**2) * zi.real
    linez_common = np.array([ feede_common**2 / w for w in power ])

    # common point

    if data.get("direct"):
        direct_common = np.argmax(power) 
        linez_common *= power[direct_common] / data["power"]
        feede_common = np.sqrt(data["power"] * parallel(linez_common))
    print('! Z in parallel {:16.5g}'.format(parallel(linez_common)))

    # handle tie

    if data.get("tie"):
        isum = np.sum([ ii[i-1] for i in data["tie"] ])
        for i in data["tie"]: 
            ii[i-1] = isum
        zi = ei / ii
        power = np.abs(ii**2) * zi.real
        linez_common = [ feede_common**2 / w for w in power ]

    # power divider

    if data.get("k2bt"):
        linez = linez_common
    else:
        linez = [ np.sign(w) * data["feed"] for w in power ]
        method = [ [ lmatch(linez[i], linez_common[i]), lmatch(linez_common[i], linez[i]) ] for i in range(n) ] 

    # ACU

    # acu = [np.concatenate([[[ np.inf, 0 ]] * 2, [[ np.nan, np.nan ]]*2 ])] * n
    acu = [ np.concatenate([ lmatch(zi[i], linez[i]), lmatch(linez[i], zi[i]) ]) for i in range(n) ]

    # generate all four combinations for each feed line: neg/pos, regular/reverse

    combo = np.array([ [ i // (4 ** (n - k - 1)) % 4 for k in range(n) ] for i in range(4 ** n) ])

    # calculate solutions

    print("! MHZ LINE   POWER               ZA        LMATCH                  ZIN        ELINE                    ", end="")
    print("PI                          TEE              PHASOR            ZOUT         EOUT      ", end="")
    if data.get("divider3"):
        print("        LMATCH          SHIFT          ZFEED        EFEED      ", end="")
    if data.get("divider1"):
        print("  SHUNTPH /     N          ZFEED         EFEED      ", end="")
    print("  TOTALPH   POWER", end="")
    print()

    for d in combo:
        net = np.array([ acu[i][k] for i, k in enumerate(d) ])
        if np.any(np.isnan(net.flatten())): continue

        print('!')
        for ref in range(n):

            # antenna

            line = np.array([ ei, ii ]).T
            pin = [ watts(v) for v in line ]

            # ATU

            for i, m, reverse in zip(range(n), net, d > 1):
                if not np.isinf(m[0]): 
                    line[i] = lmatchnet(line[i], m, reverse)
            zo = line[:,0] / line[:,1]

            # ATU to phasor feed lines

            if data.get("tline2"):
                x = to_complex(data["tline2"][i], f=frequency, vf=data["vf"])
                line[i] = multiply(tline(np.rad2deg(np.angle(x)), zo=np.abs(x)), line[i])

            ################

            for num in range(2**n if data.get('divider3') else 1):

                adjust = [0] * n
                

                if data.get("direct") and data.get("divider2"):
                    if ref != np.argmax(power):
                        continue

                if data.get("divider3"):
                    for i in range(n):
                        index = 1 if num & 2**i else 0
                        reverse = 1 if np.isnan(method[i][0][index][0]) else 0
                        v = [linez[i], 1]
                        v = lmatchnet(v, method[i][reverse][index], reverse)
                        adjust[i] = np.angle(v[0])

                if data.get("divider1"):
                    for i in range(n):
                        if np.abs((line[i][0] / line[i][1]).real - feede_common**2 / power[i]) > 1e-3:
                            adjust[i] = shuntmatch(P=watts(line[i]), R=linez[i], V=feede_common, L=data["l"], F=frequency*1e6, K=data["k"])

                for i, m, reverse in zip(range(n), net, d > 1):

                    # summary (frequency, power, zantenna)

                    print('{:<7g} {:2d}'.format(frequency, i + 1), end="")
                    print(' {:7.3f}'.format(pin[i]), end="")
                    print(' {:16.5g}'.format(zi[i]), end="")

                    # ACU using l-match

                    if reverse:
                        print(' {:>8s} / {:>8s}'.format(component(m[1], frequency), component(m[0], frequency)), end="")
                    else:
                        print(' {:>8s} \\ {:>8s}'.format(component(m[0], frequency), component(m[1], frequency)), end="")

                    print(' {:14.2f}'.format(zo[i]), end="")
                    assert(np.abs(zo[i].imag) < 1e-3) 

                    # voltage out of ACU

                    print(' {:9.4f} {:8.3f}'.format(np.abs(line[i][0]), np.rad2deg(np.angle(line[i][0]))), end="")

                    zfeed = zo[i].real
                    ref_theta = np.angle(line[ref][0])

                    if data.get("divider2"):
                        zfeed = feede_common**2 / power[i] 

                    if data.get("divider3") or data.get("divider1"):
                        ref_theta -= adjust[i] - adjust[ref]

                    theta = np.rad2deg(np.angle(line[i][0]) - ref_theta)
                    theta = np.mod(theta + 180, 360) - 180

                    # phase shift

                    v = line[i].copy()
                    x1, x2, x3 = pishift(-theta, zo[i].real, zfeed)
                    print(' {:>8s} {:>8s} {:>8s}'.format(component(x1, frequency), component(x2, frequency), component(x3, frequency)), end="")
                    if np.abs(theta) > 1e-3: 
                        v = pinet(v, x1, x2, x3)
                    assert(np.abs((v[0]/v[1]).imag) < 1e-3) 
                    assert(np.abs(np.mod(np.rad2deg(np.angle(v[0]) - ref_theta) + 180, 360) - 180) < 1e-3)

                    v = line[i].copy()
                    x1, x2, x3 = teeshift(-theta, zo[i].real, zfeed)
                    print(' | {:>8s} {:>8s} {:>8s}'.format(component(x1, frequency), component(x2, frequency), component(x3, frequency)), end="")
                    if np.abs(theta) > 1e-3: 
                        v = teenet(v, x1, x2, x3)
                    assert(np.abs((v[0]/v[1]).imag) < 1e-3) 
                    assert(np.abs(np.mod(np.rad2deg(np.angle(v[0]) - ref_theta) + 180, 360) - 180) < 1e-3)

                    # results

                    zout = v[0] / v[1]
                    print(' {:8.3f}{:1s}'.format(theta, '*' if np.abs(theta) > 100 else ''), end="")
                    print(' {:14.2f}'.format(zout), end="")
                    print(' {:9.4f} {:8.3f}'.format(np.abs(v[0]), np.rad2deg(np.angle(v[0]))), end="")
                    assert(np.abs(zout.imag) < 1e-3) 

                    ###################

                    if data.get("divider3"):
                        index = 1 if num & 2**i else 0
                        reverse = 1 if np.isnan(method[i][0][index][0]) else 0
                        if not data.get("direct") or direct_common != i:
                            x = method[i][reverse][index]
                            v = lmatchnet(v, x, reverse)
                        else:
                            x = [ np.nan ] * 2
                        if reverse:
                            print(' {:>8s} / {:>8s}'.format(component(x[1], frequency), component(x[0], frequency)), end="")
                        else:
                            print(' {:>8s} \\ {:>8s}'.format(component(x[0], frequency), component(x[1], frequency)), end="")

                        zout = v[0] / v[1]
                        print(' {:8.3f}'.format(np.rad2deg(-adjust[i])), end="")
                        print(' {:14.2f}'.format(zout), end="")
                        print(' {:9.4f} {:8.3f}'.format(np.abs(v[0]), np.rad2deg(np.angle(v[0]))), end="")
                        assert(np.abs(zout.imag) < 1e-3) 

                    if data.get("divider1"):
                        if not data.get("direct") or direct_common != i:
                            x = shuntmatch(P=watts(line[i]), R=linez[i], V=feede_common, L=data["l"], F=frequency*1e6, K=data["k"], flag=1)
                            v = teenet(v, *x)
                            print(' {:8.3f}'.format(np.rad2deg(-adjust[i])), end="")
                            print(' / {:5.3f}'.format(np.sqrt(x[1] / (x[1] + x[2]))), end="")
                        else:
                            print('        - /     -', end="")
                        zout = v[0] / v[1]
                        print(' {:14.2f} '.format(zout), end="")
                        print(' {:9.4f} {:8.3f}'.format(np.abs(v[0]), np.rad2deg(np.angle(v[0]))), end="")

                    ###################

                    print(' {:8.3f}'.format(np.rad2deg(np.angle(line[i][0]) - np.angle(v[0]))), end="")
                    print(' {:7.3f}'.format(watts(v)), end="")
                    assert(np.abs(watts(v) - pin[i]) < 1e-3)
                    print()


if __name__ == "__main__":
    import sys
    np.seterr(divide='ignore', invalid='ignore')
    main(*sys.argv[1:])

