#!/usr/bin/python3

import sys, subprocess, tempfile, os
import numpy as np

defaults = {
    "diameter": 25 / 1000,
    "losses": 0,
    "loading": 0,
    "segments": 21,
    "vf": .66
}


def lmatch(ZS, ZL, reverse=False):
    """
    ZS <---+---X2--< ZL
           X1   
    """
    if reverse: ZS, ZL = ZL, ZS
    RS, XS = ZS.real, ZS.imag
    RL, XL = ZL.real, ZL.imag
    QS = RS / RL - 1 + XS**2 / (RS * RL)
    Q = np.sqrt(QS)
    X1 = (XS + np.array([1, -1]) * Q * RS) / (RS / RL - 1)
    X2 = -(XL + np.array([1, -1]) * Q * RL)
    return np.array([X1, X2]).T


def run_process(text):
    name = tempfile.mktemp()
    command = 'nec2c -i %s -o /dev/stdout' % name
    with open(name, "wb") as f:
        f.write(text.encode()) 
    proc = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE)
    result = proc.stdout.read().decode()
    proc.wait()
    os.unlink(name)
    return result


def run_nec(text):
    tag = None
    im = []
    buf = run_process(text)
    f = iter(buf.splitlines())
    for line in f:
        data = line.split()
        if len(data) == 10 and data[0].isdigit() and '.' in line: break
    while True:
        data = line.split() 
        if not len(data): break
        x = np.complex(np.double(data[6]), np.double(data[7]))
        if tag != data[1]:
            im.append(x)
            tag = data[1]
        line = next(f)
    return im


def generate_input(data, voltages):
    frequency = data["frequency"]
    elements = data['elements']
    height = data['height']
    radius = data["diameter"] / 2
    losses = data["losses"]
    loading = data["loading"]
    segments = data["segments"]
    text = ""
    n = len(elements)
    for i in range(n):
        tag = i + 1
        fmt = "GW {tag} {segments} {x:g} {y:g} 0 {x:g} {y:g} {height} {radius}\n"
        text += fmt.format(tag=tag, segments=segments, 
                           x=elements[i][0], y=elements[i][1], 
                           height=height, radius=radius)
    text += "GE 1\n"  # ground plane is present
    text += "GN 1\n"  # perfect ground
    text += "FR 0 0 0 0 {:f}\n".format(frequency)
    for i in range(n):
        tag = i + 1
        text += "LD 4 {:d} 1 1 {:f} {:f}\n".format(tag, losses, loading)
    for i in range(n):
        tag = i + 1
        text += "EX 0 {:d} 1 0 {:g} {:g}\n".format(tag, voltages[i].real, voltages[i].imag)
    text += "XQ\n"
    text += "EN\n"
    return text


def multiply(zij, ii):
    ei = zij * np.matrix(ii).T
    return np.array(ei).T[0]


def autoload(data):
    d = { "elements": [ (0, 0) ] }
    ei = [ 1 ]
    ii = run_nec(generate_input(dict(data, **d), ei))
    zself = 1 / ii[0]
    print('! autoload vertical base = {:.4f}j'.format(-zself.imag))
    data["loading"] = -zself.imag


def mutual(data):
    n = len(data["elements"])
    zij = np.zeros((n, n), dtype=np.complex)
    for k in range(n):
        ei = np.ones(n) * 1e-20
        ei[k] = 1
        ii = run_nec(generate_input(data, ei))
        zij[:,k] = ii
    zij = np.array(np.linalg.inv(np.matrix(zij)))
    return zij


def error_norm(zij, data):
    n = zij.shape[0]
    ii = np.ones(n)
    ei = multiply(zij, ii)
    err = ii - run_nec(generate_input(data, ei))
    print('! error norm       = {:g}'.format(np.linalg.norm(err)))


def to_complex(buf, f=None, vf=None):
    buf = buf.strip()
    if '/' in buf:
        r, theta = buf.split('/')
        if theta[-2:] == 'ft':
            theta = np.double(theta[:-2]) * .3048
            theta = 360 * theta / vf / (300 / f)
        elif theta[-1:] == 'm':
            theta = np.double(theta[:-1])
            theta = 360 * theta / vf / (300 / f)
        return np.double(r) * np.exp(1j * np.deg2rad(np.double(theta)))
    else:
        return np.complex(buf)


def to_distance(buf):
    buf = buf.strip()
    if len(buf) > 2:
        suffix = buf[-2:]
        s = buf[:-2]
        if suffix == 'cm':
            return np.double(s) * .01
        if suffix == 'mm':
            return np.double(s) * .001
        if suffix == 'in':
            return np.double(s) * .0254
        if suffix == 'ft':
            return np.double(s) * .3048
    return np.double(buf)
    

def parallel(*zi):
    return 1 / np.sum([ 1 / x for x in zi ])


def tline(deg, zo=50):
    theta = np.deg2rad(deg)
    return np.matrix([
        [ np.cos(theta), 1j * zo * np.sin(theta) ],
        [ 1j * np.sin(theta) / zo, np.cos(theta) ]
    ])


def print_drive(zij, data):
    n = zij.shape[0]
    freq = data["frequency"]
    ii = np.array(data["currents"])
    ei = multiply(zij, ii)
    # handle tlines
    for i, x in enumerate(data["tlines"]):
        x = to_complex(x, f=freq, vf=data["vf"])
        ei[i], ii[i] = multiply(tline(np.rad2deg(np.angle(x)), zo=np.abs(x)), [ei[i], ii[i]])
    zi = ei / ii
    ztot = parallel(zi)
    print('{:<8g}'.format(freq), end="")
    print(','.join([ ' {:8.4f} {:+8.4f}j'.format(x.real, x.imag) for x in zi ]))
    print('! E in MA notation =', end="")
    print(','.join([ ' {:8.4f} {:8.4f}'.format(np.abs(x), np.rad2deg(np.angle(x))) for x in ei ]))
    print('! I in MA notation =', end="")
    print(','.join([ ' {:8.4f} {:8.4f}'.format(np.abs(x), np.rad2deg(np.angle(x))) for x in ii ]))
    print('! Z in parallel    = {:8.4f} {:+8.4f}j'.format(ztot.real, ztot.imag))


def print_mutual(zij, data):
    n = zij.shape[0]
    freq = data["frequency"]
    print('{:<8g}'.format(freq), end="")
    for i in range(n):
        if i > 0: print('{:<8s}'.format(''), end="")
        print(','.join([ ' {:8.4f} {:+8.4f}j'.format(
              zij[i][j].real, zij[i][j].imag) for j in range(n) ]))

   
def main(*args):
    args = list(args)
    kw = { "elements": [], "tlines": [] }
    while args:
        opt = args.pop(0)
        if opt == '-debug':
            kw["debug"] = True
        elif opt == '-autoload':
            kw["autoload"] = True
        elif opt == '-freq':
            kw["frequencies"] = [ np.double(x) for x in args.pop(0).split(',') ]
        elif opt == '-loss':
            kw["losses"] = np.double(args.pop(0))
        elif opt == '-load':
            kw["loading"] = np.double(args.pop(0))
        elif opt == '-segs':
            kw["segments"] = np.int(args.pop(0))
        elif opt == '-height':
            kw["height"] = to_distance(args.pop(0))
        elif opt == '-diam':
            kw["diameter"] = to_distance(args.pop(0))
        elif opt == '-el':
            kw["elements"].append([ to_distance(x) for x in args.pop(0).split(',') ])
        elif opt == '-currents':
            kw["currents"] = [ to_complex(x) for x in args.pop(0).split(',') ]
        elif opt == '-tlines':
            kw["tlines"] = args.pop(0).split(',')
        elif opt == '-vf':
            kw["vf"] = np.double(args.pop(0))
        else:
            raise ValueError

    kw = dict(defaults, **kw)
    print("! MHZ Z RI R 1")
    for freq in kw["frequencies"]:
        kw["frequency"] = freq

        if kw.get('autoload'):
            autoload(kw)
        zij = mutual(kw)

        # display results
        if kw.get("currents"):
            print_drive(zij, kw)
        else:
            print_mutual(zij, kw)

        # calculate error norm
        if kw.get('debug'):
            error_norm(zij, kw)


if __name__ == "__main__":
    np.set_printoptions(precision=3)
    main(*sys.argv[1:])


#   print(fm('Fxxsxxccxxsxx','MHZ','SHUNT','SERIES','!','SERIES','SHUNT','ZS','ZL','SHUNT','SERIES','!','SERIES','SHUNT'))
#   for f, S in zip(nw.f, nw.s):
#       GS, GL, GIN, GOUT = matching(S, data.get('gs'), data.get('gl'))
#       ZS, ZL = g2z(GS), g2z(GL)
#       for i in range(2):
#           print(fm('F', f / 1e6), 
#                 fm('xxs', *lmatch(ZLINE, np.conj(ZS))[i], '!', f=f),
#                 fm('xx', *lmatch(ZLINE, np.conj(ZS), 'r')[i], f=f), 
#                 fm('cc', ZS, ZL),
#                 fm('xxs', *lmatch(np.conj(ZL), ZLINE)[i], '!', f=f),
#                 fm('xx', *lmatch(np.conj(ZL), ZLINE, 'r')[i], f=f))

